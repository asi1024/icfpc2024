// Generated by Haxe 4.3.4
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class BigIntWrapper {
	static fromInt(val) {
		return BigInt(val);
	}
	static fromString(val) {
		return BigInt(val);
	}
	static toString(this1) {
		return this1.toString();
	}
	static add(a,b) {
		return a + b;
	}
	static sub(a,b) {
		return a - b;
	}
	static mul(a,b) {
		return a * b;
	}
	static div(a,b) {
		return a / b;
	}
	static mod(a,b) {
		return a % b;
	}
	static minus(a) {
		return -a;
	}
	static eq(a,b) {
		return a == b;
	}
	static neq(a,b) {
		return a != b;
	}
	static lt(a,b) {
		return a < b;
	}
	static gt(a,b) {
		return a > b;
	}
	static leq(a,b) {
		return a <= b;
	}
	static geq(a,b) {
		return a >= b;
	}
	static toInt(this1) {
		return Number(this1);
	}
}
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
}
EReg.__name__ = true;
class HxOverrides {
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
var CellData = $hxEnums["CellData"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"CellData",toString:$estr}
	,Int: ($_=function(a) { return {_hx_index:1,a:a,__enum__:"CellData",toString:$estr}; },$_._hx_name="Int",$_.__params__ = ["a"],$_)
	,Arrow: ($_=function(di,dj) { return {_hx_index:2,di:di,dj:dj,__enum__:"CellData",toString:$estr}; },$_._hx_name="Arrow",$_.__params__ = ["di","dj"],$_)
	,Op: ($_=function(op) { return {_hx_index:3,op:op,__enum__:"CellData",toString:$estr}; },$_._hx_name="Op",$_.__params__ = ["op"],$_)
};
CellData.__constructs__ = [CellData.None,CellData.Int,CellData.Arrow,CellData.Op];
class _$Main_CellDataTools {
	static toString(data) {
		switch(data._hx_index) {
		case 0:
			return "";
		case 1:
			return BigIntWrapper.toString(data.a);
		case 2:
			let _g = data.dj;
			switch(data.di) {
			case -1:
				if(_g == 0) {
					return "^";
				} else {
					return "ERR";
				}
				break;
			case 0:
				switch(_g) {
				case -1:
					return "<";
				case 1:
					return ">";
				default:
					return "ERR";
				}
				break;
			case 1:
				if(_g == 0) {
					return "v";
				} else {
					return "ERR";
				}
				break;
			default:
				return "ERR";
			}
			break;
		case 3:
			switch(data.op) {
			case 0:
				return "+";
			case 1:
				return "-";
			case 2:
				return "*";
			case 3:
				return "/";
			case 4:
				return "%";
			case 5:
				return "=";
			case 6:
				return "≠";
			case 7:
				return "@";
			case 8:
				return "A";
			case 9:
				return "B";
			case 10:
				return "S";
			}
			break;
		}
	}
}
_$Main_CellDataTools.__name__ = true;
class Cell {
	constructor(i,j,data) {
		if(data == null) {
			data = CellData.None;
		}
		this.willBeRemoved = false;
		this.next = null;
		this.selected = false;
		this.text = "";
		this.i = i;
		this.j = j;
		this.data = data;
	}
	copy() {
		return new Cell(this.i,this.j,this.data);
	}
}
Cell.__name__ = true;
class Field {
	constructor(t) {
		if(t == null) {
			t = 0;
		}
		this.cells = [];
		this.t = t;
		let _g = 0;
		while(_g < 32) {
			let i = _g++;
			this.cells.push(new Cell(i,0));
			this.cells.push(new Cell(i,1));
			this.cells.push(new Cell(i,2));
			this.cells.push(new Cell(i,3));
			this.cells.push(new Cell(i,4));
			this.cells.push(new Cell(i,5));
			this.cells.push(new Cell(i,6));
			this.cells.push(new Cell(i,7));
			this.cells.push(new Cell(i,8));
			this.cells.push(new Cell(i,9));
			this.cells.push(new Cell(i,10));
			this.cells.push(new Cell(i,11));
			this.cells.push(new Cell(i,12));
			this.cells.push(new Cell(i,13));
			this.cells.push(new Cell(i,14));
			this.cells.push(new Cell(i,15));
			this.cells.push(new Cell(i,16));
			this.cells.push(new Cell(i,17));
			this.cells.push(new Cell(i,18));
			this.cells.push(new Cell(i,19));
			this.cells.push(new Cell(i,20));
			this.cells.push(new Cell(i,21));
			this.cells.push(new Cell(i,22));
			this.cells.push(new Cell(i,23));
			this.cells.push(new Cell(i,24));
			this.cells.push(new Cell(i,25));
			this.cells.push(new Cell(i,26));
			this.cells.push(new Cell(i,27));
			this.cells.push(new Cell(i,28));
			this.cells.push(new Cell(i,29));
			this.cells.push(new Cell(i,30));
			this.cells.push(new Cell(i,31));
		}
	}
	cellAt(i,j) {
		return this.cells[(i & 31) << 5 | j & 31];
	}
	inBounds(i,j) {
		if(i == (i & 31)) {
			return j == (j & 31);
		} else {
			return false;
		}
	}
	copy(dt) {
		if(dt == null) {
			dt = 0;
		}
		let res = new Field(this.t + dt);
		let _g = 0;
		while(_g < 1024) {
			let i = _g++;
			res.cells[i] = this.cells[i].copy();
		}
		return res;
	}
}
Field.__name__ = true;
class World {
	constructor() {
		this.failReason = "";
		this.times = [];
		this.ticks = [];
		this.input = new Field();
	}
	run(a,b) {
		this.ticks.length = 0;
		this.times.length = 0;
		this.failReason = "";
		let f = this.input.copy();
		let _g = 0;
		let _g1 = f.cells;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			let _g2 = c.data;
			if(_g2._hx_index == 3 && _g2.op == 8) {
				c.data = CellData.Int(a);
			}
			let _g3 = c.data;
			if(_g3._hx_index == 3 && _g3.op == 9) {
				c.data = CellData.Int(b);
			}
		}
		let _gthis = this;
		let _g2 = 0;
		while(_g2 < 1000) {
			++_g2;
			this.ticks.push(f);
			if(this.times.length != f.t) {
				throw haxe_Exception.thrown("assertion error");
			}
			this.times.push(f);
			f = f.copy(1);
			let _g = 0;
			let _g1 = f.cells;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				let _g2 = c.data;
				switch(_g2._hx_index) {
				case 0:
					break;
				case 1:
					break;
				case 2:
					let _g3 = _g2.di;
					let _g4 = _g2.dj;
					let src = f.cellAt(c.i - _g3,c.j - _g4);
					let dst = f.cellAt(c.i + _g3,c.j + _g4);
					if(src.data != CellData.None) {
						if(dst.next != null) {
							_gthis.failReason = "written twice at (" + dst.i + ", " + dst.j + ")";
						}
						dst.next = src.data;
						src.willBeRemoved = true;
					}
					break;
				case 3:
					let op = _g2.op;
					let l = f.cellAt(c.i,c.j - 1);
					let t = f.cellAt(c.i - 1,c.j);
					let b = f.cellAt(c.i + 1,c.j);
					let r = f.cellAt(c.i,c.j + 1);
					let binOp = function(f) {
						let _g = l.data;
						let _g1 = t.data;
						if(_g._hx_index == 1) {
							if(_g1._hx_index == 1) {
								l.willBeRemoved = true;
								t.willBeRemoved = true;
								let res = f(_g.a,_g1.a);
								if(b.next != null) {
									_gthis.failReason = "written twice at (" + b.i + ", " + b.j + ")";
								}
								b.next = CellData.Int(res);
								if(r.next != null) {
									_gthis.failReason = "written twice at (" + r.i + ", " + r.j + ")";
								}
								r.next = CellData.Int(res);
							}
						}
					};
					let binOpPass = function(f) {
						if(l.data != CellData.None && r.data != CellData.None && f(l.data,t.data)) {
							l.willBeRemoved = true;
							t.willBeRemoved = true;
							let data = l.data;
							if(b.next != null) {
								_gthis.failReason = "written twice at (" + b.i + ", " + b.j + ")";
							}
							b.next = data;
							let data1 = t.data;
							if(r.next != null) {
								_gthis.failReason = "written twice at (" + r.i + ", " + r.j + ")";
							}
							r.next = data1;
						}
					};
					switch(op) {
					case 0:
						binOp(function(x,y) {
							return BigIntWrapper.add(x,y);
						});
						break;
					case 1:
						binOp(function(x,y) {
							return BigIntWrapper.sub(x,y);
						});
						break;
					case 2:
						binOp(function(x,y) {
							return BigIntWrapper.mul(x,y);
						});
						break;
					case 3:
						binOp(function(x,y) {
							return BigIntWrapper.div(x,y);
						});
						break;
					case 4:
						binOp(function(x,y) {
							return BigIntWrapper.mod(x,y);
						});
						break;
					case 5:case 6:
						binOpPass(function(x,y) {
							let tmp;
							switch(x._hx_index) {
							case 1:
								tmp = y._hx_index == 1 && BigIntWrapper.eq(x.a,y.a);
								break;
							case 3:
								tmp = y._hx_index == 3 && x.op == y.op;
								break;
							default:
								tmp = false;
							}
							return tmp == (op == 5);
						});
						break;
					case 7:
						let _g5 = l.data;
						let _g6 = r.data;
						let _g7 = b.data;
						if(_g5._hx_index == 1) {
							let _g = _g5.a;
							if(_g6._hx_index == 1) {
								let _g1 = _g6.a;
								if(_g7._hx_index == 1) {
									let _g2 = _g7.a;
									if(t.data != CellData.None) {
										do {
											if(BigIntWrapper.leq(_g2,BigIntWrapper.fromInt(0))) {
												this.failReason = "dt must be positive";
												break;
											}
											let x = BigIntWrapper.sub(BigIntWrapper.fromInt(c.j),_g);
											let y = BigIntWrapper.sub(BigIntWrapper.fromInt(c.i),_g1);
											if(BigIntWrapper.lt(x,BigIntWrapper.fromInt(0)) || BigIntWrapper.geq(x,BigIntWrapper.fromInt(32))) {
												this.failReason = "x out of bounds: " + BigIntWrapper.toString(x);
												break;
											}
											if(BigIntWrapper.lt(y,BigIntWrapper.fromInt(0)) || BigIntWrapper.geq(y,BigIntWrapper.fromInt(32))) {
												this.failReason = "y out of bounds: " + BigIntWrapper.toString(y);
												break;
											}
											let t = BigIntWrapper.sub(BigIntWrapper.fromInt(f.t),_g2);
											if(BigIntWrapper.lt(t,BigIntWrapper.fromInt(0))) {
												this.failReason = "try to warp to negative time: " + BigIntWrapper.toString(t);
												break;
											}
										} while(false);
									}
								}
							}
						}
						break;
					case 8:case 9:case 10:
						break;
					}
					break;
				}
			}
			if(this.failReason != "") {
				break;
			}
			let _g3 = 0;
			let _g4 = f.cells;
			while(_g3 < _g4.length) {
				let c = _g4[_g3];
				++_g3;
				if(c.willBeRemoved) {
					c.data = CellData.None;
				}
				if(c.next != null) {
					c.data = c.next;
				}
			}
		}
	}
}
World.__name__ = true;
var Mode = $hxEnums["Mode"] = { __ename__:true,__constructs__:null
	,Edit: {_hx_name:"Edit",_hx_index:0,__enum__:"Mode",toString:$estr}
	,Input: ($_=function(index) { return {_hx_index:1,index:index,__enum__:"Mode",toString:$estr}; },$_._hx_name="Input",$_.__params__ = ["index"],$_)
	,Paste: {_hx_name:"Paste",_hx_index:2,__enum__:"Mode",toString:$estr}
	,Write: ($_=function(cell) { return {_hx_index:3,cell:cell,__enum__:"Mode",toString:$estr}; },$_._hx_name="Write",$_.__params__ = ["cell"],$_)
	,View: {_hx_name:"View",_hx_index:4,__enum__:"Mode",toString:$estr}
};
Mode.__constructs__ = [Mode.Edit,Mode.Input,Mode.Paste,Mode.Write,Mode.View];
class pot_core_App {
	constructor(canvas,inputTarget,captureKey,captureWheel) {
		if(pot_core_App._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(canvas,inputTarget,captureKey,captureWheel);
	}
	_hx_constructor(canvas,inputTarget,captureKey,captureWheel) {
		if(captureWheel == null) {
			captureWheel = true;
		}
		if(captureKey == null) {
			captureKey = false;
		}
		if(inputTarget == null) {
			inputTarget = pot_input_InputTarget.Canvas;
		}
		this.canvas = canvas;
		this.pot = new pot_core_Pot(this,canvas);
		switch(inputTarget._hx_index) {
		case 0:
			this.input = new pot_input_Input(canvas,this.pot,canvas,captureKey,captureWheel);
			break;
		case 1:
			this.input = new pot_input_Input(canvas,this.pot,window.document.documentElement,captureKey,captureWheel);
			break;
		case 2:
			this.input = null;
			break;
		}
		this.frameCount = -1;
		this.setup();
		this.pot.beginObservation();
	}
	resized() {
	}
	setup() {
	}
	update() {
	}
	draw() {
	}
	static isWorker() {
		try {
			return window.document == null;
		} catch( _g ) {
			return true;
		}
	}
}
pot_core_App.__name__ = true;
class Main extends pot_core_App {
	constructor(canvas,inputTarget,captureKey,captureWheel) {
		pot_core_App._hx_skip_constructor = true;
		super();
		pot_core_App._hx_skip_constructor = false;
		this._hx_constructor(canvas,inputTarget,captureKey,captureWheel);
	}
	_hx_constructor(canvas,inputTarget,captureKey,captureWheel) {
		this.inputs = [BigIntWrapper.fromInt(0),BigIntWrapper.fromInt(0)];
		this.cursorJ = 16;
		this.cursorI = 16;
		this.tick = 0;
		this.playing = false;
		this.copiedCells = [];
		this.dragging = false;
		this.selecting = true;
		this.textInput = "";
		this.mode = Mode.Edit;
		this.panning = false;
		this.panPos = new muun_la__$Vec2_Vec2Data(0,0);
		this.scale = 32;
		this.center = new muun_la__$Vec2_Vec2Data(16.,16.);
		this.w = new World();
		super._hx_constructor(canvas,inputTarget,captureKey,captureWheel);
	}
	setup() {
		this.g = new pot_graphics_bitmap_BitmapGraphics(this.canvas.getContext("2d",null));
		this.pot.start();
	}
	update() {
		let mouse = this.input.mouse;
		let screen = mouse.pos;
		let a = this.pot.get_size();
		let b = this.scale;
		let b1 = this.center;
		let x = (screen.x - a.x * 0.5) / b + b1.x;
		let y = (screen.y - a.y * 0.5) / b + b1.y;
		if(mouse.dright == 1) {
			let this1 = this.panPos;
			this1.x = x;
			this1.y = y;
		}
		if(mouse.dright == -1) {
			this.panning = false;
		}
		if(mouse.right) {
			let a = this.panPos;
			let this1 = this.center;
			let a1 = this1;
			this1.x = a1.x + (a.x - x);
			this1.y = a1.y + (a.y - y);
		}
		if(mouse.wheelY != 0) {
			let a = this.scale *= Math.exp(-mouse.wheelY * 0.005);
			this.scale = a < 4 ? 4 : a > 128 ? 128 : a;
			let screen = this.input.mouse.pos;
			let a1 = this.pot.get_size();
			let b = this.scale;
			let b1 = this.center;
			let this1 = this.center;
			let a2 = this1;
			this1.x = a2.x + (x - ((screen.x - a1.x * 0.5) / b + b1.x));
			this1.y = a2.y + (y - ((screen.y - a1.y * 0.5) / b + b1.y));
		}
		let this1 = this.center;
		let x1 = 1 * 0;
		let y1 = 1 * 0;
		let x2 = 1 * 32;
		let y2 = 1 * 32;
		let a1 = this.center;
		let x3 = a1.x;
		let x4 = a1.y;
		this1.x = x3 < x1 ? x1 : x3 > x2 ? x2 : x3;
		this1.y = x4 < y1 ? y1 : x4 > y2 ? y2 : x4;
		this.processInput();
	}
	key(keyValue) {
		return pot_input_Keyboard.isKeyDown(this.input.keyboard,keyValue);
	}
	editText() {
		let _gthis = this;
		if(this.mode._hx_index == 1) {
			pot_input_Keyboard.forEachDownKey(this.input.keyboard,function(c) {
				switch(c) {
				case "-":
					_gthis.textInput = "-";
					break;
				case "Backspace":
					_gthis.textInput = HxOverrides.substr(_gthis.textInput,0,_gthis.textInput.length - 1);
					break;
				default:
					if(pot_input_KeyValue.DIGITS.includes(c)) {
						_gthis.textInput += c;
						let bi;
						try {
							bi = BigIntWrapper.fromString(_gthis.textInput);
						} catch( _g ) {
							_gthis.textInput = c;
							bi = BigIntWrapper.fromString(_gthis.textInput);
						}
						_gthis.textInput = BigIntWrapper.toString(bi);
					}
				}
			});
		} else {
			pot_input_Keyboard.forEachDownKey(this.input.keyboard,function(c) {
				switch(c) {
				case "!":case "#":
					_gthis.textInput = "≠";
					break;
				case "%":
					_gthis.textInput = "%";
					break;
				case "*":
					_gthis.textInput = "*";
					break;
				case "+":
					_gthis.textInput = "+";
					break;
				case "-":
					_gthis.textInput = "-";
					break;
				case "/":
					_gthis.textInput = "/";
					break;
				case "=":
					_gthis.textInput = "=";
					break;
				case "@":
					_gthis.textInput = "@";
					break;
				case "ArrowDown":case "j":case "v":
					_gthis.textInput = "v";
					break;
				case ",":case "<":case "ArrowLeft":case "h":
					_gthis.textInput = "<";
					break;
				case ".":case ">":case "ArrowRight":case "l":
					_gthis.textInput = ">";
					break;
				case "ArrowUp":case "^":case "k":
					_gthis.textInput = "^";
					break;
				case "Backspace":
					_gthis.textInput = HxOverrides.substr(_gthis.textInput,0,_gthis.textInput.length - 1);
					break;
				case "a":
					_gthis.textInput = "A";
					break;
				case "b":
					_gthis.textInput = "B";
					break;
				case "s":
					_gthis.textInput = "S";
					break;
				default:
					if(pot_input_KeyValue.DIGITS.includes(c)) {
						_gthis.textInput += c;
						if(Std.parseInt(_gthis.textInput) == null) {
							_gthis.textInput = c;
						}
						let a = Std.parseInt(_gthis.textInput);
						_gthis.textInput = Std.string(a < -99 ? -99 : a > 99 ? 99 : a);
					}
				}
			});
		}
	}
	clearSelection(f) {
		let _g = 0;
		let _g1 = f.cells;
		while(_g < _g1.length) _g1[_g++].selected = false;
	}
	deleteSelection(f) {
		let _g = 0;
		let _g1 = f.cells;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			if(c.selected) {
				c.data = CellData.None;
				c.selected = false;
			}
		}
	}
	pasteAt(f,i,j) {
		this.clearSelection(f);
		let _g = 0;
		let _g1 = this.copiedCells;
		while(_g < _g1.length) {
			let src = _g1[_g];
			++_g;
			let ii = i + src.i;
			let jj = j + src.j;
			if(f.inBounds(ii,jj)) {
				let dst = f.cellAt(ii,jj);
				dst.data = src.data;
				dst.selected = true;
			}
		}
	}
	selectedCells(f) {
		let _this = f.cells;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(v.selected) {
				_g.push(v);
			}
		}
		return _g;
	}
	runSimulation() {
		this.w.run(this.inputs[0],this.inputs[1]);
	}
	processInput() {
		let mouse = this.input.mouse;
		let kb = this.input.keyboard;
		let f = this.w.input;
		let _g = this.mode;
		switch(_g._hx_index) {
		case 0:
			do {
				let pos = mouse.pos;
				let a = this.pot.get_size();
				let b = this.scale;
				let b1 = this.center;
				let j = Math.floor((pos.x - a.x * 0.5) / b + b1.x);
				let i = Math.floor((pos.y - a.y * 0.5) / b + b1.y);
				let cell = i < 0 || i >= 32 || j < 0 || j >= 32 ? null : f.cellAt(i,j);
				if(cell != null) {
					if(mouse.dleft == 1) {
						this.cursorI = cell.i;
						this.cursorJ = cell.j;
						this.dragging = true;
						this.selecting = !cell.selected;
						if(!pot_input_Keyboard.isShiftDown(kb) && !cell.selected) {
							this.clearSelection(f);
						}
					}
					if(!mouse.left) {
						this.dragging = false;
					}
					if(mouse.left && this.dragging) {
						this.cursorI = cell.i;
						this.cursorJ = cell.j;
						cell.selected = this.selecting;
					}
					let cellToEdit = this.key("e") ? f.cellAt(this.cursorI,this.cursorJ) : null;
					if(cellToEdit != null) {
						this.mode = Mode.Write(cellToEdit);
						this.textInput = _$Main_CellDataTools.toString(cellToEdit.data);
						break;
					}
					let cut = this.key("x");
					if(this.key("c") || cut) {
						let sel = this.selectedCells(f);
						if(sel.length != 0) {
							this.copiedCells.length = 0;
							let mins_0 = 32;
							let mins_1 = 32;
							let maxs_0 = 0;
							let maxs_1 = 0;
							let _g = 0;
							while(_g < sel.length) {
								let c = sel[_g];
								++_g;
								let a = mins_0;
								let b = c.i;
								mins_0 = a < b ? a : b;
								let a1 = mins_1;
								let b1 = c.j;
								mins_1 = a1 < b1 ? a1 : b1;
								let a2 = maxs_0;
								let b2 = c.i;
								maxs_0 = a2 > b2 ? a2 : b2;
								let a3 = maxs_1;
								let b3 = c.j;
								maxs_1 = a3 > b3 ? a3 : b3;
							}
							let mi = mins_0 + maxs_0 >> 1;
							let mj = mins_1 + maxs_1 >> 1;
							let _g1 = 0;
							while(_g1 < sel.length) {
								let c = sel[_g1];
								++_g1;
								this.copiedCells.push(new Cell(c.i - mi,c.j - mj,c.data));
								if(cut) {
									c.selected = false;
									c.data = CellData.None;
								}
							}
							break;
						}
					}
				}
				if(this.key("w") || this.key("k") || this.key("ArrowUp")) {
					let a = this.cursorI - 1;
					this.cursorI = a < 0 ? 0 : a > 31 ? 31 : a;
					this.clearSelection(f);
					f.cellAt(this.cursorI,this.cursorJ).selected = true;
					break;
				}
				if(this.key("s") || this.key("j") || this.key("ArrowDown")) {
					let a = this.cursorI + 1;
					this.cursorI = a < 0 ? 0 : a > 31 ? 31 : a;
					this.clearSelection(f);
					f.cellAt(this.cursorI,this.cursorJ).selected = true;
					break;
				}
				if(this.key("a") || this.key("h") || this.key("ArrowLeft")) {
					let a = this.cursorJ - 1;
					this.cursorJ = a < 0 ? 0 : a > 31 ? 31 : a;
					this.clearSelection(f);
					f.cellAt(this.cursorI,this.cursorJ).selected = true;
					break;
				}
				if(this.key("d") || this.key("l") || this.key("ArrowRight")) {
					let a = this.cursorJ + 1;
					this.cursorJ = a < 0 ? 0 : a > 31 ? 31 : a;
					this.clearSelection(f);
					f.cellAt(this.cursorI,this.cursorJ).selected = true;
					break;
				}
				if(this.key("1")) {
					this.textInput = "0";
					this.mode = Mode.Input(0);
					break;
				}
				if(this.key("2")) {
					this.textInput = "0";
					this.mode = Mode.Input(1);
					break;
				}
				if(this.key("Escape")) {
					this.clearSelection(f);
					break;
				}
				if(this.key("Delete")) {
					this.deleteSelection(f);
					break;
				}
				if(this.key("v") && this.copiedCells.length != 0) {
					this.mode = Mode.Paste;
					break;
				}
				if(this.key("Enter")) {
					this.runSimulation();
					this.mode = Mode.View;
					this.tick = 0;
					break;
				}
			} while(false);
			break;
		case 1:
			let _g1 = _g.index;
			this.editText();
			if(this.key("e")) {
				try {
					this.inputs[_g1] = BigIntWrapper.fromString(this.textInput);
				} catch( _g ) {
				}
				this.mode = Mode.Edit;
			}
			if(this.key("Escape")) {
				this.mode = Mode.Edit;
			}
			break;
		case 2:
			if(mouse.dright == 1 || this.key("Escape")) {
				this.mode = Mode.Edit;
			}
			let pos = mouse.pos;
			let a = this.pot.get_size();
			let b = this.scale;
			let b1 = this.center;
			let j = Math.floor((pos.x - a.x * 0.5) / b + b1.x);
			let i = Math.floor((pos.y - a.y * 0.5) / b + b1.y);
			let cell = i < 0 || i >= 32 || j < 0 || j >= 32 ? null : f.cellAt(i,j);
			if(cell != null && mouse.dleft == 1) {
				this.cursorI = cell.i;
				this.cursorJ = cell.j;
				this.pasteAt(f,cell.i,cell.j);
				this.mode = Mode.Edit;
			}
			break;
		case 3:
			let _g2 = _g.cell;
			this.editText();
			_g2.text = this.textInput == "" ? " " : this.textInput;
			if(this.key("Escape")) {
				_g2.text = "";
				this.mode = Mode.Edit;
			} else if(this.key("e")) {
				_g2.text = "";
				let tmp;
				switch(this.textInput) {
				case "":
					tmp = CellData.None;
					break;
				case "%":
					tmp = CellData.Op(4);
					break;
				case "*":
					tmp = CellData.Op(2);
					break;
				case "+":
					tmp = CellData.Op(0);
					break;
				case "-":
					tmp = CellData.Op(1);
					break;
				case "/":
					tmp = CellData.Op(3);
					break;
				case "<":
					tmp = CellData.Arrow(0,-1);
					break;
				case "=":
					tmp = CellData.Op(5);
					break;
				case ">":
					tmp = CellData.Arrow(0,1);
					break;
				case "@":
					tmp = CellData.Op(7);
					break;
				case "A":
					tmp = CellData.Op(8);
					break;
				case "B":
					tmp = CellData.Op(9);
					break;
				case "S":
					tmp = CellData.Op(10);
					break;
				case "^":
					tmp = CellData.Arrow(-1,0);
					break;
				case "v":
					tmp = CellData.Arrow(1,0);
					break;
				case "≠":
					tmp = CellData.Op(6);
					break;
				default:
					let num = Std.parseInt(this.textInput);
					tmp = num != null ? CellData.Int(BigIntWrapper.fromInt(num)) : CellData.None;
				}
				_g2.data = tmp;
				this.mode = Mode.Edit;
			}
			break;
		case 4:
			if(this.key(" ")) {
				this.playing = !this.playing;
			}
			if(this.key("a")) {
				let b = this.tick - 1;
				this.tick = 0 > b ? 0 : b;
			}
			if(this.key("d") || this.playing && this.frameCount % 10 == 0) {
				let a = this.w.ticks.length - 1;
				let b = this.tick + 1;
				this.tick = a < b ? a : b;
			}
			if(this.playing && this.tick == this.w.ticks.length - 1) {
				this.playing = false;
			}
			if(this.key("q")) {
				this.tick = 0;
			}
			if(this.key("e")) {
				this.tick = this.w.ticks.length - 1;
			}
			if(this.key("Escape")) {
				this.mode = Mode.Edit;
			}
			break;
		}
	}
	draw() {
		this.g.clearImpl(1,1,1,1);
		this.drawWorld();
	}
	drawWorld() {
		if(this.mode == Mode.View) {
			this.drawField(this.w.ticks[this.tick]);
		} else {
			this.drawField(this.w.input);
		}
		this.drawInfo();
	}
	drawInfo() {
		this.g.fillColorImpl(1,1,1,0.9);
		this.g.c2d.fillRect(0,0,256,400);
		this.g.c2d.font = "bold" + " " + 16 + "px \"" + "Arial" + "\", " + "sans-serif";
		this.g.fillColorImpl(0,0,0,1);
		this.g.c2d.textBaseline = "top";
		this.g.c2d.textAlign = "left";
		let _g = this.mode;
		let text;
		switch(_g._hx_index) {
		case 0:
			text = "Edit";
			break;
		case 1:
			text = "Editing Input " + "AB".charAt(_g.index);
			break;
		case 2:
			text = "Paste";
			break;
		case 3:
			let _g1 = _g.cell;
			text = "Editing (" + _g1.i + ", " + _g1.j + ")";
			break;
		case 4:
			text = "View";
			break;
		}
		this.g.c2d.fillText("Mode: " + text,0,0.0);
		let _g2 = this.mode;
		switch(_g2._hx_index) {
		case 0:
			this.g.c2d.fillText("RMB & Drag: Pan",0,27.);
			this.g.c2d.fillText("Wheel: Zoom",0,45.);
			this.g.c2d.fillText("LMB & Drag: (De)Select",0,72.);
			this.g.c2d.fillText("ESC: Deselect All",0,90.);
			this.g.c2d.fillText("WASD, HJKL, Arrows: Move",0,117.);
			this.g.c2d.fillText("E: Edit Cell",0,144.);
			this.g.c2d.fillText("DEL: Erase Cells",0,171.);
			this.g.c2d.fillText("X: Cut Cells",0,189.);
			this.g.c2d.fillText("C: Copy Cells",0,207.);
			this.g.c2d.fillText("V: Paste Cells",0,225.);
			let text1 = "1: Edit Input A ( = " + BigIntWrapper.toString(this.inputs[0]) + ")";
			this.g.c2d.fillText(text1,0,252.);
			let text2 = "2: Edit Input B ( = " + BigIntWrapper.toString(this.inputs[1]) + ")";
			this.g.c2d.fillText(text2,0,270.);
			this.g.c2d.fillText("Enter: Run Simulation",0,297.);
			break;
		case 1:
			this.g.c2d.fillText("AB".charAt(_g2.index) + " = " + this.textInput,0,27.);
			this.g.c2d.fillText("E: Confirm",0,54.);
			this.g.c2d.fillText("ESC: Cancel",0,72.);
			break;
		case 2:
			this.g.c2d.fillText("LMB: Confirm",0,27.);
			this.g.c2d.fillText("RMB, ESC: Cancel",0,45.);
			break;
		case 3:
			this.g.c2d.fillText("A, B, S: I/O",0,27.);
			this.g.c2d.fillText("+, -, *, /, %, @: Ops",0,54.);
			this.g.c2d.fillText("=: Equals",0,72.);
			this.g.c2d.fillText("!, #: Not Equals",0,90.);
			this.g.c2d.fillText("HJKL, Arrows: Arrow",0,117.);
			this.g.c2d.fillText("0-9: Integer",0,144.);
			this.g.c2d.fillText("Backspace: Erace Last",0,171.);
			this.g.c2d.fillText("E: Confirm",0,198.);
			this.g.c2d.fillText("ESC: Cancel",0,216.);
			break;
		case 4:
			this.g.c2d.fillText("Showing Tick " + (this.tick + 1) + "/" + this.w.ticks.length,0,27.);
			this.g.c2d.fillText("time = " + (this.w.ticks[this.tick].t + 1),0,45.);
			this.g.c2d.fillText("A: Prev Tick",0,72.);
			this.g.c2d.fillText("D: Next Tick",0,90.);
			this.g.c2d.fillText("Q: First Tick",0,108.);
			this.g.c2d.fillText("E: Last Tick",0,126.);
			this.g.c2d.fillText("Space: Play/Pause",0,144.);
			this.g.c2d.fillText("ESC: Edit mode",0,171.);
			break;
		}
	}
	drawField(f) {
		this.g.strokeColorImpl(0,0,0,1);
		this.g.c2d.textAlign = "center";
		this.g.c2d.textBaseline = "middle";
		this.g.c2d.font = "bold" + " " + 0.8 + "px \"" + "Courier New" + "\", " + "monospace";
		this.g.c2d.save();
		this.g.c2d.translate(this.pot.width * 0.5,this.pot.height * 0.5);
		this.g.c2d.scale(this.scale,this.scale);
		this.g.c2d.translate(-this.center.x,-this.center.y);
		this.g.c2d.lineWidth = 0.02;
		let _g = 0;
		while(_g < 32) {
			let i = _g++;
			let _g1 = 0;
			while(_g1 < 32) {
				let j = _g1++;
				this.g.c2d.save();
				this.g.c2d.translate(j,i);
				let cell = f.cellAt(i,j);
				if(cell.selected) {
					this.g.fillColorImpl(0.75,0.75,1,1);
				} else {
					this.g.fillColorImpl(1,1,1,1);
				}
				this.g.c2d.fillRect(0,0,1,1);
				let _g = this.mode;
				if(_g._hx_index == 3) {
					if(_g.cell == cell) {
						this.g.fillColorImpl(1,0.5,0.5,1);
						this.g.c2d.fillRect(0,0,1,1);
					}
				}
				this.g.strokeColorImpl(0,0,0,1);
				this.g.c2d.strokeRect(0,0,1,1);
				let text = cell.text != "" ? cell.text : _$Main_CellDataTools.toString(cell.data);
				if(text != "" && text != " ") {
					this.g.fillColorImpl(0,0,0,1);
					this.g.c2d.fillText(text,0.5,0.5,1);
				}
				this.g.c2d.restore();
			}
		}
		if(this.mode == Mode.Paste) {
			let screen = this.input.mouse.pos;
			let a = this.pot.get_size();
			let b = this.scale;
			let b1 = this.center;
			let x = (screen.x - a.x * 0.5) / b + b1.x;
			let y = (screen.y - a.y * 0.5) / b + b1.y;
			let _g = 0;
			let _g1 = this.copiedCells;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				this.g.c2d.save();
				this.g.c2d.translate(Math.floor(c.j + x),Math.floor(c.i + y));
				if(c.selected) {
					this.g.fillColorImpl(0.75,0.75,1,0.5);
				} else {
					this.g.fillColorImpl(1,1,1,0.5);
				}
				this.g.c2d.fillRect(0,0,1,1);
				let _g2 = this.mode;
				if(_g2._hx_index == 3) {
					if(_g2.cell == c) {
						this.g.fillColorImpl(1,0.5,0.5,0.5);
						this.g.c2d.fillRect(0,0,1,1);
					}
				}
				this.g.strokeColorImpl(0,0,0,0.5);
				this.g.c2d.strokeRect(0,0,1,1);
				let text = c.text != "" ? c.text : _$Main_CellDataTools.toString(c.data);
				if(text != "" && text != " ") {
					this.g.fillColorImpl(0,0,0,0.5);
					this.g.c2d.fillText(text,0.5,0.5,1);
				}
				this.g.c2d.restore();
			}
		}
		if(this.mode != Mode.View) {
			this.g.c2d.lineWidth = 0.1;
			this.g.strokeColorImpl(0,0,0,1);
			this.g.c2d.strokeRect(this.cursorJ,this.cursorI,1,1);
		}
		this.g.c2d.restore();
	}
	static main() {
		new Main(window.document.getElementById("canvas"),null,true,true);
	}
}
Main.__name__ = true;
Math.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		let v = parseInt(x);
		if(isNaN(v)) {
			return null;
		}
		return v;
	}
}
Std.__name__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = true;
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
}
haxe_ValueException.__name__ = true;
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
}
haxe_ds_StringMap.__name__ = true;
class haxe_ds__$StringMap_StringMapKeyValueIterator {
	constructor(h) {
		this.h = h;
		this.keys = Object.keys(h);
		this.length = this.keys.length;
		this.current = 0;
	}
	hasNext() {
		return this.current < this.length;
	}
	next() {
		let key = this.keys[this.current++];
		return { key : key, value : this.h[key]};
	}
}
haxe_ds__$StringMap_StringMapKeyValueIterator.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
class muun_la_ImVec2 {
	static toString(this1) {
		return "ImVec2(" + this1.x + ", " + this1.y + ")";
	}
}
class muun_la_ImVec3 {
	static toString(this1) {
		return "ImVec3(" + this1.x + ", " + this1.y + ", " + this1.z + ")";
	}
}
class muun_la_ImVec4 {
	static toString(this1) {
		return "ImVec4(" + this1.x + ", " + this1.y + ", " + this1.z + ", " + this1.w + ")";
	}
}
class muun_la_Mat2 {
	static _new(e00,e01,e10,e11) {
		return new muun_la__$Mat2_Mat2Data(e00,e01,e10,e11);
	}
	static toString(this1) {
		return "Mat3(" + this1.e00 + ", " + this1.e01 + "; " + this1.e10 + ", " + this1.e11 + ")";
	}
}
class muun_la__$Mat2_Mat2Data {
	constructor(e00,e01,e10,e11) {
		this.e00 = e00;
		this.e01 = e01;
		this.e10 = e10;
		this.e11 = e11;
	}
}
muun_la__$Mat2_Mat2Data.__name__ = true;
class muun_la_Mat3 {
	static _new(e00,e01,e02,e10,e11,e12,e20,e21,e22) {
		return new muun_la__$Mat3_Mat3Data(e00,e01,e02,e10,e11,e12,e20,e21,e22);
	}
	static toString(this1) {
		return "Mat3(" + this1.e00 + ", " + this1.e01 + ", " + this1.e02 + "; " + this1.e10 + ", " + this1.e11 + ", " + this1.e12 + "; " + this1.e20 + ", " + this1.e21 + ", " + this1.e22 + ")";
	}
}
class muun_la__$Mat3_Mat3Data {
	constructor(e00,e01,e02,e10,e11,e12,e20,e21,e22) {
		this.e00 = e00;
		this.e01 = e01;
		this.e02 = e02;
		this.e10 = e10;
		this.e11 = e11;
		this.e12 = e12;
		this.e20 = e20;
		this.e21 = e21;
		this.e22 = e22;
	}
}
muun_la__$Mat3_Mat3Data.__name__ = true;
class muun_la_Mat4 {
	static _new(e00,e01,e02,e03,e10,e11,e12,e13,e20,e21,e22,e23,e30,e31,e32,e33) {
		return new muun_la__$Mat4_Mat4Data(e00,e01,e02,e03,e10,e11,e12,e13,e20,e21,e22,e23,e30,e31,e32,e33);
	}
	static toString(this1) {
		return "Mat4(" + this1.e00 + ", " + this1.e01 + ", " + this1.e02 + ", " + this1.e03 + "; " + this1.e10 + ", " + this1.e11 + ", " + this1.e12 + ", " + this1.e13 + "; " + this1.e20 + ", " + this1.e21 + ", " + this1.e22 + ", " + this1.e23 + "; " + this1.e30 + ", " + this1.e31 + ", " + this1.e32 + ", " + this1.e33 + ")";
	}
}
class muun_la__$Mat4_Mat4Data {
	constructor(e00,e01,e02,e03,e10,e11,e12,e13,e20,e21,e22,e23,e30,e31,e32,e33) {
		this.e00 = e00;
		this.e01 = e01;
		this.e02 = e02;
		this.e03 = e03;
		this.e10 = e10;
		this.e11 = e11;
		this.e12 = e12;
		this.e13 = e13;
		this.e20 = e20;
		this.e21 = e21;
		this.e22 = e22;
		this.e23 = e23;
		this.e30 = e30;
		this.e31 = e31;
		this.e32 = e32;
		this.e33 = e33;
	}
}
muun_la__$Mat4_Mat4Data.__name__ = true;
class muun_la_Quat {
	static toString(this1) {
		return "Quat(" + this1.x + ", " + this1.y + ", " + this1.z + "; " + this1.w + ")";
	}
}
class muun_la__$Quat_QuatData {
	constructor(x,y,z,w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
}
muun_la__$Quat_QuatData.__name__ = true;
class muun_la_Vec2 {
	static _new(x,y) {
		return new muun_la__$Vec2_Vec2Data(x,y);
	}
	static toString(this1) {
		return "Vec2(" + this1.x + ", " + this1.y + ")";
	}
}
class muun_la__$Vec2_Vec2Data {
	constructor(x,y) {
		this.x = x;
		this.y = y;
	}
}
muun_la__$Vec2_Vec2Data.__name__ = true;
class muun_la_Vec3 {
	static _new(x,y,z) {
		return new muun_la__$Vec3_Vec3Data(x,y,z);
	}
	static toString(this1) {
		return "Vec3(" + this1.x + ", " + this1.y + ", " + this1.z + ")";
	}
}
class muun_la__$Vec3_Vec3Data {
	constructor(x,y,z) {
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
muun_la__$Vec3_Vec3Data.__name__ = true;
class muun_la_Vec4 {
	static _new(x,y,z,w) {
		return new muun_la__$Vec4_Vec4Data(x,y,z,w);
	}
	static toString(this1) {
		return "Vec4(" + this1.x + ", " + this1.y + ", " + this1.z + ", " + this1.w + ")";
	}
}
class muun_la__$Vec4_Vec4Data {
	constructor(x,y,z,w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
}
muun_la__$Vec4_Vec4Data.__name__ = true;
class pot_concurrent_Async {
}
pot_concurrent_Async.__name__ = true;
class pot_concurrent_Blocker {
	constructor() {
		let resolveFunc;
		this.value = new Promise(function(resolve,reject) {
			resolveFunc = resolve;
		});
		this.unblock = function() {
			resolveFunc(null);
		};
	}
}
pot_concurrent_Blocker.__name__ = true;
var pot_core_FrameRate = $hxEnums["pot.core.FrameRate"] = { __ename__:true,__constructs__:null
	,Auto: {_hx_name:"Auto",_hx_index:0,__enum__:"pot.core.FrameRate",toString:$estr}
	,Fixed: ($_=function(fps) { return {_hx_index:1,fps:fps,__enum__:"pot.core.FrameRate",toString:$estr}; },$_._hx_name="Fixed",$_.__params__ = ["fps"],$_)
};
pot_core_FrameRate.__constructs__ = [pot_core_FrameRate.Auto,pot_core_FrameRate.Fixed];
class pot_core_FrameRateManager {
	constructor(update,draw) {
		this.doNotAdjust = false;
		this.frameSkipEnabled = true;
		this.count = 0;
		this.targetInterval = 16.666666666666668;
		this.update = update;
		this.draw = draw;
	}
	start() {
		if(this.running) {
			return;
		}
		this.prevTime = window.performance.now() - this.targetInterval;
		this.estimatedUpdateTime = this.targetInterval;
		this.running = true;
		window.setTimeout($bind(this,this.loop),0);
	}
	stop() {
		if(!this.running) {
			return;
		}
		this.running = false;
	}
	setFrameRate(frameRate) {
		this.targetInterval = 1000 / frameRate;
	}
	loop() {
		(async () => {
		if(!this.running) {
			return;
		}
		this.count++;
		if(this.doNotAdjust) {
			let blocker = new pot_concurrent_Blocker();
			if(pot_core_FrameRateManager.catchErrors) {
				try {
					this.update(1,blocker.unblock);
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g);
					window.alert(Std.string(_g1));
				}
			} else {
				this.update(1,blocker.unblock);
			}
			await blocker.value;
			let f = this.draw;
			if(pot_core_FrameRateManager.catchErrors) {
				try {
					f();
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g);
					window.alert(Std.string(_g1));
				}
			} else {
				f();
			}
		} else {
			let currentTime = window.performance.now();
			let a = this.lastDrawBegin + this.targetInterval * 4;
			let b = currentTime + 4;
			let maxDrawBegin = a > b ? a : b;
			let maxUpdateCount;
			if(!this.frameSkipEnabled || this.count < 10) {
				maxUpdateCount = 1;
			} else {
				let b = Math.round((maxDrawBegin - currentTime) / this.estimatedUpdateTime);
				maxUpdateCount = 1 > b ? 1 : b;
			}
			let a1 = this.targetInterval * 0.01;
			let b1 = this.targetInterval - this.estimatedUpdateTime;
			let idealUpdateCountFloat = (currentTime - this.prevTime) / (a1 > b1 ? a1 : b1);
			let idealUpdateCount = idealUpdateCountFloat > 0.2 && idealUpdateCountFloat < 1.8 ? 1 : Math.round(idealUpdateCountFloat);
			let updateCount = idealUpdateCount < maxUpdateCount ? idealUpdateCount : maxUpdateCount;
			if(updateCount > 0) {
				let p = currentTime;
				let nextLast = false;
				let _g = 0;
				let _g1 = updateCount;
				while(_g < _g1) {
					let i = _g++;
					let blocker = new pot_concurrent_Blocker();
					if(pot_core_FrameRateManager.catchErrors) {
						try {
							this.update(nextLast ? 1 : (i + 1) / updateCount,blocker.unblock);
						} catch( _g ) {
							let _g1 = haxe_Exception.caught(_g);
							window.alert(Std.string(_g1));
						}
					} else {
						this.update(nextLast ? 1 : (i + 1) / updateCount,blocker.unblock);
					}
					await blocker.value;
					let n = window.performance.now();
					this.estimatedUpdateTime += (n - p - this.estimatedUpdateTime) * 0.5;
					p = n;
					this.prevTime += this.targetInterval;
					if(nextLast) {
						break;
					}
					if(n > maxDrawBegin) {
						nextLast = true;
					}
				}
				let a = this.prevTime;
				let a1 = this.targetInterval * 4;
				let b = p - (a1 > 4 ? a1 : 4);
				this.prevTime = a > b ? a : b;
				this.lastDrawBegin = p;
				let f = this.draw;
				if(pot_core_FrameRateManager.catchErrors) {
					try {
						f();
					} catch( _g ) {
						let _g1 = haxe_Exception.caught(_g);
						window.alert(Std.string(_g1));
					}
				} else {
					f();
				}
			}
		}
		window.requestAnimationFrame($bind(this,this.loop));
		})();
	}
}
pot_core_FrameRateManager.__name__ = true;
class pot_core_Pot {
	constructor(app,canvas) {
		this.onEndUpdate = null;
		this.asyncUpdate = false;
		this.app = app;
		this.canvas = canvas;
		this.resize();
		this.frameRateManager = new pot_core_FrameRateManager($bind(this,this.update),$bind(this,this.draw));
		this.frameRate(pot_core_FrameRate.Fixed(60));
	}
	frameRate(frameRate) {
		switch(frameRate._hx_index) {
		case 0:
			this.frameRateManager.setFrameRate(60);
			this.frameRateManager.doNotAdjust = true;
			break;
		case 1:
			this.frameRateManager.setFrameRate(frameRate.fps);
			this.frameRateManager.doNotAdjust = false;
			break;
		}
	}
	frameSkip(enable) {
		this.frameRateManager.frameSkipEnabled = enable;
	}
	isMobile() {
		return new EReg("iPhone|Android.+Mobile","").match($global.navigator.userAgent);
	}
	beginObservation() {
		let _gthis = this;
		this.obs = new ResizeObserver(function(_) {
			if(_gthis.resize()) {
				_gthis.app.resized();
			}
		});
		this.obs.observe(this.canvas);
		this.obs.observe(window.document.documentElement);
		this.app.resized();
	}
	get_size() {
		return new muun_la__$Vec2_Vec2Data(this.width,this.height);
	}
	resize() {
		let w = this.canvas.clientWidth;
		let h = this.canvas.clientHeight;
		let dpr = window.devicePixelRatio;
		if(this.width != w || this.height != h || this.pixelRatio != dpr) {
			this.width = w;
			this.height = h;
			this.pixelRatio = dpr;
			this.canvas.width = this.width * this.pixelRatio + 0.5 | 0;
			this.canvas.height = this.height * this.pixelRatio + 0.5 | 0;
			return true;
		} else {
			return false;
		}
	}
	start() {
		this.frameRateManager.start();
	}
	stop() {
		this.frameRateManager.stop();
	}
	update(substepRatio,callback) {
		this.app.frameCount++;
		if(this.app.input != null) {
			this.app.input.update(substepRatio);
		}
		if(this.asyncUpdate) {
			this.onEndUpdate = callback;
			this.app.update();
		} else {
			this.app.update();
			callback();
		}
	}
	endUpdate() {
		if(!this.asyncUpdate) {
			throw haxe_Exception.thrown("enable async update is disabled");
		}
		if(this.onEndUpdate == null) {
			throw haxe_Exception.thrown("callback function not set");
		}
		this.onEndUpdate();
		this.onEndUpdate = null;
	}
	draw() {
		this.app.draw();
	}
}
pot_core_Pot.__name__ = true;
class pot_graphics_bitmap_Bitmap {
	constructor(width,height) {
		this.imageData = null;
		this.pixels = null;
		this.numPixels = -1;
		this.height = -1;
		this.width = -1;
		this.canvas = window.document.createElement("canvas");
		this.c2d = this.canvas.getContext("2d",{ willReadFrequently : true});
		this.g = new pot_graphics_bitmap_BitmapGraphics(this.c2d);
		this.setSize(width,height);
	}
	getRawCanvas() {
		return this.canvas;
	}
	getGraphics() {
		return this.g;
	}
	setSize(width,height) {
		this.width = width;
		this.height = height;
		this.numPixels = width * height;
		this.canvas.width = width;
		this.canvas.height = height;
		this.pixels = null;
	}
	loadPixels() {
		if(this.pixels == null || this.pixels.length != this.numPixels) {
			this.pixels = new Array(this.numPixels);
		}
		this.imageData = this.c2d.getImageData(0,0,this.width,this.height);
		let data = this.imageData.data;
		let idx = 0;
		let _g = 0;
		let _g1 = this.numPixels;
		while(_g < _g1) {
			let r = data[idx++];
			let g = data[idx++];
			let b = data[idx++];
			this.pixels[_g++] = data[idx++] << 24 | r << 16 | g << 8 | b;
		}
	}
	updatePixels() {
		if(this.pixels == null || this.pixels.length != this.numPixels) {
			throw haxe_Exception.thrown("incompatible pixel data");
		}
		let data = this.imageData.data;
		let idx = 0;
		let _g = 0;
		let _g1 = this.numPixels;
		while(_g < _g1) {
			let pix = this.pixels[_g++];
			data[idx++] = pix >> 16 & 255;
			data[idx++] = pix >> 8 & 255;
			data[idx++] = pix & 255;
			data[idx++] = pix >>> 24;
		}
		this.c2d.putImageData(this.imageData,0,0);
	}
}
pot_graphics_bitmap_Bitmap.__name__ = true;
class pot_graphics_bitmap_BitmapGraphics {
	constructor(c2d) {
		this.canvas = c2d.canvas;
		this.c2d = c2d;
	}
	clearImpl(r,g,b,a) {
		this.c2d.save();
		this.c2d.clearRect(0,0,this.canvas.width,this.canvas.height);
		this.c2d.globalAlpha = 1;
		this.c2d.globalCompositeOperation = "source-over";
		let a1 = a;
		if(a == null) {
			a1 = 1;
		}
		this.fillColorImpl(r,g,b,a1);
		this.c2d.fillRect(0,0,this.canvas.width,this.canvas.height);
		this.c2d.restore();
	}
	fillColorImpl(r,g,b,a) {
		this.c2d.fillStyle = "rgba(" + (r * 255 + 0.5 | 0) + ", " + (g * 255 + 0.5 | 0) + ", " + (b * 255 + 0.5 | 0) + ", " + a + ")";
	}
	strokeColorImpl(r,g,b,a) {
		this.c2d.strokeStyle = "rgba(" + (r * 255 + 0.5 | 0) + ", " + (g * 255 + 0.5 | 0) + ", " + (b * 255 + 0.5 | 0) + ", " + a + ")";
	}
}
pot_graphics_bitmap_BitmapGraphics.__name__ = true;
class pot_graphics_bitmap_BitmapSource {
	static _new(source,width,height) {
		return new pot_graphics_bitmap__$BitmapSource_BitmapSourceData(source,width,height);
	}
	static fromBitmap(source) {
		return new pot_graphics_bitmap__$BitmapSource_BitmapSourceData(source.canvas,source.width,source.height);
	}
	static fromImageData(source) {
		return new pot_graphics_bitmap__$BitmapSource_BitmapSourceData(source,source.width,source.height);
	}
	static fromImageElement(source) {
		return new pot_graphics_bitmap__$BitmapSource_BitmapSourceData(source,source.naturalWidth,source.naturalHeight);
	}
	static fromCanvasElement(source) {
		return new pot_graphics_bitmap__$BitmapSource_BitmapSourceData(source,source.width,source.height);
	}
	static fromVideoElement(source) {
		return new pot_graphics_bitmap__$BitmapSource_BitmapSourceData(source,source.videoWidth,source.videoHeight);
	}
}
class pot_graphics_bitmap__$BitmapSource_BitmapSourceData {
	constructor(source,width,height) {
		this.source = source;
		this.width = width;
		this.height = height;
	}
}
pot_graphics_bitmap__$BitmapSource_BitmapSourceData.__name__ = true;
class pot_input_CodeValue {
	static fromString(code) {
		if(pot_input_CodeValue.ALL.indexOf(code) == -1) {
			return null;
		}
		return code;
	}
}
class pot_input_Input {
	constructor(canvas,pot,target,captureKey,captureWheel) {
		this.pointer = new pot_input_Pointer(this);
		this.mouse = new pot_input_Mouse();
		this.touches = new pot_input__$Touches_TouchesData();
		this.keyboard = captureKey ? new pot_input__$Keyboard_KeyboardData() : null;
		this.scalingMode = 0;
		this.addEvents(canvas,target,pot,captureWheel);
	}
	addEvents(canvas,target,pot,captureWheel) {
		this.mouse.addEvents(canvas,target,this,pot,captureWheel);
		let this1 = this.touches;
		let canvas1 = canvas;
		let elem = target;
		let input = this;
		let pot1 = pot;
		elem.addEventListener("touchstart",function(e) {
			if(e.cancelable) {
				e.preventDefault();
			}
			let touches = e.changedTouches;
			let _g = 0;
			let _g1 = touches.length;
			while(_g < _g1) {
				let rawTouch = touches[_g++];
				let rawId = rawTouch.identifier;
				let touch = this1.getByRawId(rawId,true);
				let x = rawTouch.clientX - elem.getBoundingClientRect().left;
				let x1;
				switch(input.scalingMode) {
				case 0:
					x1 = canvas1.width / pot1.pixelRatio / canvas1.clientWidth;
					break;
				case 1:
					x1 = canvas1.width / canvas1.clientWidth;
					break;
				}
				let x2 = x * x1;
				let y = rawTouch.clientY - elem.getBoundingClientRect().top;
				let y1;
				switch(input.scalingMode) {
				case 0:
					y1 = canvas1.height / pot1.pixelRatio / canvas1.clientHeight;
					break;
				case 1:
					y1 = canvas1.height / canvas1.clientHeight;
					break;
				}
				touch.nx = x2;
				touch.ny = y * y1;
				touch.ntouching = true;
				touch.ntouching2 = true;
			}
		},{ passive : false});
		elem.addEventListener("touchmove",function(e) {
			if(e.cancelable) {
				e.preventDefault();
			}
			let touches = e.changedTouches;
			let _g = 0;
			let _g1 = touches.length;
			while(_g < _g1) {
				let rawTouch = touches[_g++];
				let rawId = rawTouch.identifier;
				let touch = this1.getByRawId(rawId);
				if(touch != null) {
					let x = rawTouch.clientX - elem.getBoundingClientRect().left;
					let x1;
					switch(input.scalingMode) {
					case 0:
						x1 = canvas1.width / pot1.pixelRatio / canvas1.clientWidth;
						break;
					case 1:
						x1 = canvas1.width / canvas1.clientWidth;
						break;
					}
					let x2 = x * x1;
					let y = rawTouch.clientY - elem.getBoundingClientRect().top;
					let y1;
					switch(input.scalingMode) {
					case 0:
						y1 = canvas1.height / pot1.pixelRatio / canvas1.clientHeight;
						break;
					case 1:
						y1 = canvas1.height / canvas1.clientHeight;
						break;
					}
					touch.nx = x2;
					touch.ny = y * y1;
				}
			}
		},{ passive : false});
		let end = function(e) {
			if(e.cancelable) {
				e.preventDefault();
			}
			let touches = e.changedTouches;
			let _g = 0;
			let _g1 = touches.length;
			while(_g < _g1) {
				let rawTouch = touches[_g++];
				let rawId = rawTouch.identifier;
				let touch = this1.getByRawId(rawId);
				if(touch != null) {
					let x = rawTouch.clientX - elem.getBoundingClientRect().left;
					let x1;
					switch(input.scalingMode) {
					case 0:
						x1 = canvas1.width / pot1.pixelRatio / canvas1.clientWidth;
						break;
					case 1:
						x1 = canvas1.width / canvas1.clientWidth;
						break;
					}
					let x2 = x * x1;
					let y = rawTouch.clientY - elem.getBoundingClientRect().top;
					let y1;
					switch(input.scalingMode) {
					case 0:
						y1 = canvas1.height / pot1.pixelRatio / canvas1.clientHeight;
						break;
					case 1:
						y1 = canvas1.height / canvas1.clientHeight;
						break;
					}
					touch.nx = x2;
					touch.ny = y * y1;
					touch.ntouching = false;
				}
			}
		};
		elem.addEventListener("touchend",end);
		elem.addEventListener("touchcancel",end);
		if(this.keyboard != null) {
			let this1 = this.keyboard;
			let elem = window.document.documentElement;
			elem.addEventListener("keydown",function(e) {
				let code = pot_input_CodeValue.fromString(e.code);
				if(code == null) {
					return;
				}
				if(!pot_input_CodeValue.FUNCTIONS.includes(code) && e.cancelable) {
					e.preventDefault();
				}
				if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
					this1.keys.h[code] = new pot_input_Key();
				}
				this1.keys.h[code].press();
				this1.ndowns.add(e.key);
			});
			elem.addEventListener("keyup",function(e) {
				let code = pot_input_CodeValue.fromString(e.code);
				if(code == null) {
					return;
				}
				if(!pot_input_CodeValue.FUNCTIONS.includes(code) && e.cancelable) {
					e.preventDefault();
				}
				if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
					this1.keys.h[code] = new pot_input_Key();
				}
				this1.keys.h[code].release();
				this1.nups.add(e.key);
			});
			window.addEventListener("blur",function(e) {
				let h = this1.keys.h;
				let key_keys = Object.keys(h);
				let key_length = key_keys.length;
				let key_current = 0;
				while(key_current < key_length) h[key_keys[key_current++]].release();
			});
		}
	}
	update(substepRatio) {
		this.mouse.update(substepRatio);
		let this1 = this.touches;
		let i = 0;
		while(i < this1.touches.length) {
			let touch = this1.touches[i];
			touch.update(substepRatio);
			if(!touch.ptouching && !touch.touching && !touch.ntouching) {
				HxOverrides.remove(this1.touches,touch);
			} else {
				++i;
			}
		}
		if(this.keyboard != null) {
			let this1 = this.keyboard;
			let h = this1.keys.h;
			let key_keys = Object.keys(h);
			let key_length = key_keys.length;
			let key_current = 0;
			while(key_current < key_length) h[key_keys[key_current++]].update();
			this1.downs.clear();
			this1.ups.clear();
			let jsIterator = this1.ndowns.values();
			let _g_lastStep = jsIterator.next();
			while(!_g_lastStep.done) {
				let v = _g_lastStep.value;
				_g_lastStep = jsIterator.next();
				this1.downs.add(v);
			}
			let jsIterator1 = this1.ups.values();
			let _g_lastStep1 = jsIterator1.next();
			while(!_g_lastStep1.done) {
				let v = _g_lastStep1.value;
				_g_lastStep1 = jsIterator1.next();
				this1.ups.add(v);
			}
			this1.ndowns.clear();
			this1.nups.clear();
		}
		if(this.touches.touches.length > 0) {
			this.mouse.hasInput = false;
		}
		this.pointer.update();
	}
}
pot_input_Input.__name__ = true;
var pot_input_InputTarget = $hxEnums["pot.input.InputTarget"] = { __ename__:true,__constructs__:null
	,Canvas: {_hx_name:"Canvas",_hx_index:0,__enum__:"pot.input.InputTarget",toString:$estr}
	,Document: {_hx_name:"Document",_hx_index:1,__enum__:"pot.input.InputTarget",toString:$estr}
	,None: {_hx_name:"None",_hx_index:2,__enum__:"pot.input.InputTarget",toString:$estr}
};
pot_input_InputTarget.__constructs__ = [pot_input_InputTarget.Canvas,pot_input_InputTarget.Document,pot_input_InputTarget.None];
class pot_input_InputTools {
	static clientX(e) {
		return e.getBoundingClientRect().left;
	}
	static clientY(e) {
		return e.getBoundingClientRect().top;
	}
	static scaleX(canvas,mode,pixelRatio) {
		switch(mode) {
		case 0:
			return canvas.width / pixelRatio / canvas.clientWidth;
		case 1:
			return canvas.width / canvas.clientWidth;
		}
	}
	static scaleY(canvas,mode,pixelRatio) {
		switch(mode) {
		case 0:
			return canvas.height / pixelRatio / canvas.clientHeight;
		case 1:
			return canvas.height / canvas.clientHeight;
		}
	}
}
pot_input_InputTools.__name__ = true;
class pot_input_Key {
	constructor() {
		this.down = false;
		this.pdown = false;
		this.ndown = false;
		this.ndown2 = false;
		this.ddown = 0;
	}
	press() {
		this.ndown = true;
		this.ndown2 = true;
	}
	release() {
		this.ndown = false;
	}
	update() {
		this.pdown = this.down;
		this.down = this.ndown || this.ndown2;
		this.ndown2 = false;
		this.ddown = (this.down ? 1 : 0) - (this.pdown ? 1 : 0);
	}
}
pot_input_Key.__name__ = true;
class pot_input_KeyValue {
}
class pot_input_Keyboard {
	static _new() {
		return new pot_input__$Keyboard_KeyboardData();
	}
	static get(this1,code) {
		if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
			this1.keys.h[code] = new pot_input_Key();
		}
		return this1.keys.h[code];
	}
	static getNum(this1,index) {
		let code = pot_input_CodeValue.DIGITS[index];
		if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
			this1.keys.h[code] = new pot_input_Key();
		}
		return this1.keys.h[code];
	}
	static addEvents(this1,canvas,elem) {
		elem.addEventListener("keydown",function(e) {
			let code = pot_input_CodeValue.fromString(e.code);
			if(code == null) {
				return;
			}
			if(!pot_input_CodeValue.FUNCTIONS.includes(code) && e.cancelable) {
				e.preventDefault();
			}
			if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
				this1.keys.h[code] = new pot_input_Key();
			}
			this1.keys.h[code].press();
			this1.ndowns.add(e.key);
		});
		elem.addEventListener("keyup",function(e) {
			let code = pot_input_CodeValue.fromString(e.code);
			if(code == null) {
				return;
			}
			if(!pot_input_CodeValue.FUNCTIONS.includes(code) && e.cancelable) {
				e.preventDefault();
			}
			if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
				this1.keys.h[code] = new pot_input_Key();
			}
			this1.keys.h[code].release();
			this1.nups.add(e.key);
		});
		window.addEventListener("blur",function(e) {
			let h = this1.keys.h;
			let key_keys = Object.keys(h);
			let key_length = key_keys.length;
			let key_current = 0;
			while(key_current < key_length) h[key_keys[key_current++]].release();
		});
	}
	static update(this1) {
		let h = this1.keys.h;
		let key_keys = Object.keys(h);
		let key_length = key_keys.length;
		let key_current = 0;
		while(key_current < key_length) h[key_keys[key_current++]].update();
		this1.downs.clear();
		this1.ups.clear();
		let jsIterator = this1.ndowns.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			this1.downs.add(v);
		}
		let jsIterator1 = this1.ups.values();
		let _g_lastStep1 = jsIterator1.next();
		while(!_g_lastStep1.done) {
			let v = _g_lastStep1.value;
			_g_lastStep1 = jsIterator1.next();
			this1.ups.add(v);
		}
		this1.ndowns.clear();
		this1.nups.clear();
	}
	static isControlDown(this1) {
		let code = "ControlLeft";
		if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
			this1.keys.h[code] = new pot_input_Key();
		}
		if(!this1.keys.h[code].down) {
			let code = "ControlRight";
			if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
				this1.keys.h[code] = new pot_input_Key();
			}
			return this1.keys.h[code].down;
		} else {
			return true;
		}
	}
	static isShiftDown(this1) {
		let code = "ShiftLeft";
		if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
			this1.keys.h[code] = new pot_input_Key();
		}
		if(!this1.keys.h[code].down) {
			let code = "ShiftRight";
			if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
				this1.keys.h[code] = new pot_input_Key();
			}
			return this1.keys.h[code].down;
		} else {
			return true;
		}
	}
	static isAltDown(this1) {
		let code = "AltLeft";
		if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
			this1.keys.h[code] = new pot_input_Key();
		}
		if(!this1.keys.h[code].down) {
			let code = "AltRight";
			if(!Object.prototype.hasOwnProperty.call(this1.keys.h,code)) {
				this1.keys.h[code] = new pot_input_Key();
			}
			return this1.keys.h[code].down;
		} else {
			return true;
		}
	}
	static isKeyDown(this1,key) {
		return this1.downs.has(key);
	}
	static isKeyUp(this1,key) {
		return this1.ups.has(key);
	}
	static forEachDownKey(this1,f) {
		let jsIterator = this1.downs.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			f(v);
		}
	}
	static forEachUpKey(this1,f) {
		let jsIterator = this1.ups.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			f(v);
		}
	}
	static forEachCode(this1,f) {
		let _g = new haxe_ds__$StringMap_StringMapKeyValueIterator(this1.keys.h);
		while(_g.hasNext()) {
			let _g1 = _g.next();
			f(_g1.key,_g1.value);
		}
	}
}
class pot_input__$Keyboard_KeyboardData {
	constructor() {
		this.nups = new Set();
		this.ndowns = new Set();
		this.ups = new Set();
		this.downs = new Set();
		this.keys = new haxe_ds_StringMap();
	}
}
pot_input__$Keyboard_KeyboardData.__name__ = true;
class pot_input_Mouse {
	constructor() {
		this.delta = new muun_la__$Vec2_Vec2Data(0,0);
		this.pos = new muun_la__$Vec2_Vec2Data(0,0);
		this.ppos = new muun_la__$Vec2_Vec2Data(0,0);
		this.px = 0;
		this.py = 0;
		this.px2 = 0;
		this.py2 = 0;
		this.x = 0;
		this.y = 0;
		this.nx = 0;
		this.ny = 0;
		this.dx = 0;
		this.dy = 0;
		this.wheelX = 0;
		this.wheelY = 0;
		this.nwheelX = 0;
		this.nwheelY = 0;
		this.pleft = false;
		this.pmiddle = false;
		this.pright = false;
		this.left = false;
		this.middle = false;
		this.right = false;
		this.nleft = false;
		this.nmiddle = false;
		this.nright = false;
		this.nleft2 = false;
		this.nmiddle2 = false;
		this.nright2 = false;
		this.dleft = 0;
		this.dmiddle = 0;
		this.dright = 0;
		this.hasInput = false;
		this.onContent = false;
	}
	addEvents(canvas,target,input,pot,captureWheel) {
		let _gthis = this;
		target.addEventListener("mouseenter",function(e) {
			return _gthis.onContent = true;
		});
		target.addEventListener("mouseleave",function(e) {
			return _gthis.onContent = false;
		});
		target.addEventListener("mousedown",function(e) {
			_gthis.hasInput = true;
			_gthis.onContent = true;
			if(e.cancelable) {
				e.preventDefault();
			}
			switch(e.button) {
			case 0:
				_gthis.nleft = true;
				_gthis.nleft2 = true;
				break;
			case 1:
				_gthis.nmiddle = true;
				_gthis.nmiddle2 = true;
				break;
			case 2:
				_gthis.nright = true;
				_gthis.nright2 = true;
				break;
			}
			let tmp = e.clientX - canvas.getBoundingClientRect().left;
			let tmp1;
			switch(input.scalingMode) {
			case 0:
				tmp1 = canvas.width / pot.pixelRatio / canvas.clientWidth;
				break;
			case 1:
				tmp1 = canvas.width / canvas.clientWidth;
				break;
			}
			_gthis.nx = tmp * tmp1;
			let tmp2 = e.clientY - canvas.getBoundingClientRect().top;
			let tmp3;
			switch(input.scalingMode) {
			case 0:
				tmp3 = canvas.height / pot.pixelRatio / canvas.clientHeight;
				break;
			case 1:
				tmp3 = canvas.height / canvas.clientHeight;
				break;
			}
			return _gthis.ny = tmp2 * tmp3;
		});
		target.addEventListener("mouseup",function(e) {
			_gthis.hasInput = true;
			_gthis.onContent = true;
			if(e.cancelable) {
				e.preventDefault();
			}
			switch(e.button) {
			case 0:
				_gthis.nleft = false;
				break;
			case 1:
				_gthis.nmiddle = false;
				break;
			case 2:
				_gthis.nright = false;
				break;
			}
			let tmp = e.clientX - canvas.getBoundingClientRect().left;
			let tmp1;
			switch(input.scalingMode) {
			case 0:
				tmp1 = canvas.width / pot.pixelRatio / canvas.clientWidth;
				break;
			case 1:
				tmp1 = canvas.width / canvas.clientWidth;
				break;
			}
			_gthis.nx = tmp * tmp1;
			let tmp2 = e.clientY - canvas.getBoundingClientRect().top;
			let tmp3;
			switch(input.scalingMode) {
			case 0:
				tmp3 = canvas.height / pot.pixelRatio / canvas.clientHeight;
				break;
			case 1:
				tmp3 = canvas.height / canvas.clientHeight;
				break;
			}
			return _gthis.ny = tmp2 * tmp3;
		});
		target.addEventListener("mousemove",function(e) {
			_gthis.hasInput = true;
			_gthis.onContent = true;
			let tmp = e.clientX - canvas.getBoundingClientRect().left;
			let tmp1;
			switch(input.scalingMode) {
			case 0:
				tmp1 = canvas.width / pot.pixelRatio / canvas.clientWidth;
				break;
			case 1:
				tmp1 = canvas.width / canvas.clientWidth;
				break;
			}
			_gthis.nx = tmp * tmp1;
			let tmp2 = e.clientY - canvas.getBoundingClientRect().top;
			let tmp3;
			switch(input.scalingMode) {
			case 0:
				tmp3 = canvas.height / pot.pixelRatio / canvas.clientHeight;
				break;
			case 1:
				tmp3 = canvas.height / canvas.clientHeight;
				break;
			}
			return _gthis.ny = tmp2 * tmp3;
		});
		if(captureWheel) {
			target.addEventListener("wheel",function(e) {
				let scale;
				switch(e.deltaMode) {
				case 0:
					scale = 1;
					break;
				case 1:
					scale = 24;
					break;
				case 2:
					scale = 720;
					break;
				default:
					throw haxe_Exception.thrown("invalid wheel delta mode");
				}
				_gthis.nwheelX += e.deltaX * scale;
				_gthis.nwheelY += e.deltaY * scale;
				e.preventDefault();
			},{ passive : false});
		}
		target.addEventListener("contextmenu",function(e) {
			_gthis.hasInput = true;
			_gthis.onContent = true;
			e.preventDefault();
		});
		target.addEventListener("pointerdown",function(e) {
			target.setPointerCapture(e.pointerId);
		});
		target.addEventListener("pointerup",function(e) {
			target.releasePointerCapture(e.pointerId);
		});
		window.addEventListener("blur",function(e) {
			_gthis.nleft = false;
			_gthis.nmiddle = false;
			return _gthis.nright = false;
		});
	}
	update(substepRatio) {
		this.px = this.x;
		this.py = this.y;
		this.x = this.px2 + substepRatio * (this.nx - this.px2);
		this.y = this.py2 + substepRatio * (this.ny - this.py2);
		this.dx = this.x - this.px;
		this.dy = this.y - this.py;
		let this1 = this.ppos;
		this1.x = this.px;
		this1.y = this.py;
		let this2 = this.pos;
		this2.x = this.x;
		this2.y = this.y;
		let this3 = this.delta;
		this3.x = this.dx;
		this3.y = this.dy;
		this.pleft = this.left;
		this.pmiddle = this.middle;
		this.pright = this.right;
		this.left = this.nleft || this.nleft2;
		this.middle = this.nmiddle || this.nmiddle2;
		this.right = this.nright || this.nright2;
		this.nleft2 = false;
		this.nmiddle2 = false;
		this.nright2 = false;
		this.dleft = (this.left ? 1 : 0) - (this.pleft ? 1 : 0);
		this.dmiddle = (this.middle ? 1 : 0) - (this.pmiddle ? 1 : 0);
		this.dright = (this.right ? 1 : 0) - (this.pright ? 1 : 0);
		this.wheelX = this.nwheelX;
		this.wheelY = this.nwheelY;
		this.nwheelX = 0;
		this.nwheelY = 0;
		if(substepRatio == 1) {
			this.px2 = this.x;
			this.py2 = this.y;
		}
	}
}
pot_input_Mouse.__name__ = true;
class pot_input_Pointer {
	constructor(input) {
		this.touchId = -1;
		this.ddown = 0;
		this.pdown = false;
		this.down = false;
		this.dy = 0;
		this.dx = 0;
		this.y = 0;
		this.x = 0;
		this.py = 0;
		this.px = 0;
		this.hasInput = false;
		this.delta = new muun_la__$Vec2_Vec2Data(0,0);
		this.ppos = new muun_la__$Vec2_Vec2Data(0,0);
		this.pos = new muun_la__$Vec2_Vec2Data(0,0);
		this.input = input;
	}
	update() {
		if(this.input.mouse.hasInput) {
			this.touchId = -1;
			let mouse = this.input.mouse;
			this.px = mouse.px;
			this.py = mouse.py;
			this.x = mouse.x;
			this.y = mouse.y;
			this.dx = mouse.dx;
			this.dy = mouse.dy;
			this.down = mouse.left;
			this.pdown = mouse.pleft;
			this.ddown = mouse.dleft;
			this.hasInput = true;
		} else {
			this.touchId = -1;
			this.down = false;
			this.pdown = false;
			this.ddown = 0;
			this.hasInput = false;
			let _g = 0;
			let _g1 = this.input.touches;
			while(_g < _g1.touches.length) {
				let touch = _g1.touches[_g];
				++_g;
				if(this.touchId == -1 || touch.id == this.touchId) {
					this.touchId = touch.id;
					this.px = touch.px;
					this.py = touch.py;
					this.x = touch.x;
					this.y = touch.y;
					this.dx = touch.dx;
					this.dy = touch.dy;
					this.down = touch.touching;
					this.pdown = touch.ptouching;
					this.ddown = touch.dtouching;
					this.hasInput = true;
				}
			}
		}
		let this1 = this.ppos;
		this1.x = this.px;
		this1.y = this.py;
		let this2 = this.pos;
		this2.x = this.x;
		this2.y = this.y;
		let this3 = this.delta;
		this3.x = this.dx;
		this3.y = this.dy;
	}
}
pot_input_Pointer.__name__ = true;
class pot_input_Touch {
	constructor(id,rawId) {
		this.ntouching2 = false;
		this.ntouching = false;
		this.ny = 0;
		this.nx = 0;
		this.py2 = 0;
		this.px2 = 0;
		this.dtouching = 0;
		this.ptouching = false;
		this.touching = false;
		this.dy = 0;
		this.dx = 0;
		this.y = 0;
		this.x = 0;
		this.py = 0;
		this.px = 0;
		this.delta = new muun_la__$Vec2_Vec2Data(0,0);
		this.pos = new muun_la__$Vec2_Vec2Data(0,0);
		this.ppos = new muun_la__$Vec2_Vec2Data(0,0);
		this.id = id;
		this.rawId = rawId;
	}
	begin(x,y) {
		this.nx = x;
		this.ny = y;
		this.ntouching = true;
		this.ntouching2 = true;
	}
	move(x,y) {
		this.nx = x;
		this.ny = y;
	}
	end(x,y) {
		this.nx = x;
		this.ny = y;
		this.ntouching = false;
	}
	update(substepRatio) {
		if(this.ntouching2) {
			this.px = this.nx;
			this.py = this.ny;
			this.px2 = this.nx;
			this.py2 = this.ny;
		} else {
			this.px = this.x;
			this.py = this.y;
		}
		this.x = this.px2 + substepRatio * (this.nx - this.px2);
		this.y = this.py2 + substepRatio * (this.ny - this.py2);
		this.dx = this.x - this.px;
		this.dy = this.y - this.py;
		let this1 = this.ppos;
		this1.x = this.px;
		this1.y = this.py;
		let this2 = this.pos;
		this2.x = this.x;
		this2.y = this.y;
		let this3 = this.delta;
		this3.x = this.dx;
		this3.y = this.dy;
		this.ptouching = this.touching;
		this.touching = this.ntouching || this.ntouching2;
		this.ntouching2 = false;
		this.dtouching = (this.touching ? 1 : 0) - (this.ptouching ? 1 : 0);
		if(substepRatio == 1) {
			this.px2 = this.x;
			this.py2 = this.y;
		}
	}
}
pot_input_Touch.__name__ = true;
class pot_input_Touches {
	static _new() {
		return new pot_input__$Touches_TouchesData();
	}
	static get_length(this1) {
		return this1.touches.length;
	}
	static get(this1,index) {
		return this1.touches[index];
	}
	static addEvents(this1,canvas,elem,input,pot) {
		elem.addEventListener("touchstart",function(e) {
			if(e.cancelable) {
				e.preventDefault();
			}
			let touches = e.changedTouches;
			let _g = 0;
			let _g1 = touches.length;
			while(_g < _g1) {
				let rawTouch = touches[_g++];
				let rawId = rawTouch.identifier;
				let touch = this1.getByRawId(rawId,true);
				let x = rawTouch.clientX - elem.getBoundingClientRect().left;
				let x1;
				switch(input.scalingMode) {
				case 0:
					x1 = canvas.width / pot.pixelRatio / canvas.clientWidth;
					break;
				case 1:
					x1 = canvas.width / canvas.clientWidth;
					break;
				}
				let x2 = x * x1;
				let y = rawTouch.clientY - elem.getBoundingClientRect().top;
				let y1;
				switch(input.scalingMode) {
				case 0:
					y1 = canvas.height / pot.pixelRatio / canvas.clientHeight;
					break;
				case 1:
					y1 = canvas.height / canvas.clientHeight;
					break;
				}
				touch.nx = x2;
				touch.ny = y * y1;
				touch.ntouching = true;
				touch.ntouching2 = true;
			}
		},{ passive : false});
		elem.addEventListener("touchmove",function(e) {
			if(e.cancelable) {
				e.preventDefault();
			}
			let touches = e.changedTouches;
			let _g = 0;
			let _g1 = touches.length;
			while(_g < _g1) {
				let rawTouch = touches[_g++];
				let rawId = rawTouch.identifier;
				let touch = this1.getByRawId(rawId);
				if(touch != null) {
					let x = rawTouch.clientX - elem.getBoundingClientRect().left;
					let x1;
					switch(input.scalingMode) {
					case 0:
						x1 = canvas.width / pot.pixelRatio / canvas.clientWidth;
						break;
					case 1:
						x1 = canvas.width / canvas.clientWidth;
						break;
					}
					let x2 = x * x1;
					let y = rawTouch.clientY - elem.getBoundingClientRect().top;
					let y1;
					switch(input.scalingMode) {
					case 0:
						y1 = canvas.height / pot.pixelRatio / canvas.clientHeight;
						break;
					case 1:
						y1 = canvas.height / canvas.clientHeight;
						break;
					}
					touch.nx = x2;
					touch.ny = y * y1;
				}
			}
		},{ passive : false});
		let end = function(e) {
			if(e.cancelable) {
				e.preventDefault();
			}
			let touches = e.changedTouches;
			let _g = 0;
			let _g1 = touches.length;
			while(_g < _g1) {
				let rawTouch = touches[_g++];
				let rawId = rawTouch.identifier;
				let touch = this1.getByRawId(rawId);
				if(touch != null) {
					let x = rawTouch.clientX - elem.getBoundingClientRect().left;
					let x1;
					switch(input.scalingMode) {
					case 0:
						x1 = canvas.width / pot.pixelRatio / canvas.clientWidth;
						break;
					case 1:
						x1 = canvas.width / canvas.clientWidth;
						break;
					}
					let x2 = x * x1;
					let y = rawTouch.clientY - elem.getBoundingClientRect().top;
					let y1;
					switch(input.scalingMode) {
					case 0:
						y1 = canvas.height / pot.pixelRatio / canvas.clientHeight;
						break;
					case 1:
						y1 = canvas.height / canvas.clientHeight;
						break;
					}
					touch.nx = x2;
					touch.ny = y * y1;
					touch.ntouching = false;
				}
			}
		};
		elem.addEventListener("touchend",end);
		elem.addEventListener("touchcancel",end);
	}
	static update(this1,substepRatio) {
		let i = 0;
		while(i < this1.touches.length) {
			let touch = this1.touches[i];
			touch.update(substepRatio);
			if(!touch.ptouching && !touch.touching && !touch.ntouching) {
				HxOverrides.remove(this1.touches,touch);
			} else {
				++i;
			}
		}
	}
}
class pot_input__$Touches_TouchesData {
	constructor() {
		this.touches = [];
	}
	getByRawId(rawId,create) {
		if(create == null) {
			create = false;
		}
		let _g = 0;
		let _g1 = this.touches;
		while(_g < _g1.length) {
			let t = _g1[_g];
			++_g;
			if(t.rawId == rawId) {
				return t;
			}
		}
		if(create) {
			return this.newTouch(rawId);
		} else {
			return null;
		}
	}
	newTouch(rawId) {
		let minId = 0;
		while(true) {
			let tmp = minId;
			let _g = 0;
			let _g1 = this.touches;
			while(_g < _g1.length) if(_g1[_g++].id == minId) {
				++minId;
			}
			if(tmp == minId) {
				break;
			}
		}
		let touch = new pot_input_Touch(minId,rawId);
		this.touches.push(touch);
		return touch;
	}
}
pot_input__$Touches_TouchesData.__name__ = true;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
{
	String.__name__ = true;
	Array.__name__ = true;
}
js_Boot.__toStr = ({ }).toString;
pot_core_App._hx_skip_constructor = false;
var Main_SIZE_SHIFT = 5;
var Main_SIZE = 32;
var Main_SIZE_MASK = 31;
var Main_SIZE2 = 1024;
pot_core_FrameRateManager.catchErrors = false;
pot_core_FrameRateManager.UPDATE_LOAD_COEFF = 0.75;
pot_core_FrameRateManager.MAX_UPDATE_COUNT = 4;
pot_core_FrameRateManager.MIN_UPDATE_TIME = 4;
pot_core_FrameRateManager.MAX_FRAMERATE_RATIO = 4;
pot_graphics_bitmap_BitmapGraphics.PI = 3.141592653589793;
pot_graphics_bitmap_BitmapGraphics.TWO_PI = 6.2831853071795862;
pot_input_CodeValue.Escape = "Escape";
pot_input_CodeValue.Digit0 = "Digit0";
pot_input_CodeValue.Digit1 = "Digit1";
pot_input_CodeValue.Digit2 = "Digit2";
pot_input_CodeValue.Digit3 = "Digit3";
pot_input_CodeValue.Digit4 = "Digit4";
pot_input_CodeValue.Digit5 = "Digit5";
pot_input_CodeValue.Digit6 = "Digit6";
pot_input_CodeValue.Digit7 = "Digit7";
pot_input_CodeValue.Digit8 = "Digit8";
pot_input_CodeValue.Digit9 = "Digit9";
pot_input_CodeValue.Minus = "Minus";
pot_input_CodeValue.Equal = "Equal";
pot_input_CodeValue.Backspace = "Backspace";
pot_input_CodeValue.Tab = "Tab";
pot_input_CodeValue.KeyQ = "KeyQ";
pot_input_CodeValue.KeyW = "KeyW";
pot_input_CodeValue.KeyE = "KeyE";
pot_input_CodeValue.KeyR = "KeyR";
pot_input_CodeValue.KeyT = "KeyT";
pot_input_CodeValue.KeyY = "KeyY";
pot_input_CodeValue.KeyU = "KeyU";
pot_input_CodeValue.KeyI = "KeyI";
pot_input_CodeValue.KeyO = "KeyO";
pot_input_CodeValue.KeyP = "KeyP";
pot_input_CodeValue.BracketLeft = "BracketLeft";
pot_input_CodeValue.BracketRight = "BracketRight";
pot_input_CodeValue.Enter = "Enter";
pot_input_CodeValue.ControlLeft = "ControlLeft";
pot_input_CodeValue.KeyA = "KeyA";
pot_input_CodeValue.KeyS = "KeyS";
pot_input_CodeValue.KeyD = "KeyD";
pot_input_CodeValue.KeyF = "KeyF";
pot_input_CodeValue.KeyG = "KeyG";
pot_input_CodeValue.KeyH = "KeyH";
pot_input_CodeValue.KeyJ = "KeyJ";
pot_input_CodeValue.KeyK = "KeyK";
pot_input_CodeValue.KeyL = "KeyL";
pot_input_CodeValue.Semicolon = "Semicolon";
pot_input_CodeValue.Quote = "Quote";
pot_input_CodeValue.Backquote = "Backquote";
pot_input_CodeValue.ShiftLeft = "ShiftLeft";
pot_input_CodeValue.Backslash = "Backslash";
pot_input_CodeValue.KeyZ = "KeyZ";
pot_input_CodeValue.KeyX = "KeyX";
pot_input_CodeValue.KeyC = "KeyC";
pot_input_CodeValue.KeyV = "KeyV";
pot_input_CodeValue.KeyB = "KeyB";
pot_input_CodeValue.KeyN = "KeyN";
pot_input_CodeValue.KeyM = "KeyM";
pot_input_CodeValue.Comma = "Comma";
pot_input_CodeValue.Period = "Period";
pot_input_CodeValue.Slash = "Slash";
pot_input_CodeValue.ShiftRight = "ShiftRight";
pot_input_CodeValue.NumpadMultiply = "NumpadMultiply";
pot_input_CodeValue.AltLeft = "AltLeft";
pot_input_CodeValue.Space = "Space";
pot_input_CodeValue.CapsLock = "CapsLock";
pot_input_CodeValue.F1 = "F1";
pot_input_CodeValue.F2 = "F2";
pot_input_CodeValue.F3 = "F3";
pot_input_CodeValue.F4 = "F4";
pot_input_CodeValue.F5 = "F5";
pot_input_CodeValue.F6 = "F6";
pot_input_CodeValue.F7 = "F7";
pot_input_CodeValue.F8 = "F8";
pot_input_CodeValue.F9 = "F9";
pot_input_CodeValue.F10 = "F10";
pot_input_CodeValue.Numpad7 = "Numpad7";
pot_input_CodeValue.Numpad8 = "Numpad8";
pot_input_CodeValue.Numpad9 = "Numpad9";
pot_input_CodeValue.NumpadSubtract = "NumpadSubtract";
pot_input_CodeValue.Numpad4 = "Numpad4";
pot_input_CodeValue.Numpad5 = "Numpad5";
pot_input_CodeValue.Numpad6 = "Numpad6";
pot_input_CodeValue.NumpadAdd = "NumpadAdd";
pot_input_CodeValue.Numpad1 = "Numpad1";
pot_input_CodeValue.Numpad2 = "Numpad2";
pot_input_CodeValue.Numpad3 = "Numpad3";
pot_input_CodeValue.Numpad0 = "Numpad0";
pot_input_CodeValue.NumpadDecimal = "NumpadDecimal";
pot_input_CodeValue.IntlBackslash = "IntlBackslash";
pot_input_CodeValue.F11 = "F11";
pot_input_CodeValue.F12 = "F12";
pot_input_CodeValue.IntlYen = "IntlYen";
pot_input_CodeValue.NumpadEnter = "NumpadEnter";
pot_input_CodeValue.ControlRight = "ControlRight";
pot_input_CodeValue.NumpadDivide = "NumpadDivide";
pot_input_CodeValue.PrintScreen = "PrintScreen";
pot_input_CodeValue.AltRight = "AltRight";
pot_input_CodeValue.NumLock = "NumLock";
pot_input_CodeValue.Home = "Home";
pot_input_CodeValue.ArrowUp = "ArrowUp";
pot_input_CodeValue.PageUp = "PageUp";
pot_input_CodeValue.ArrowLeft = "ArrowLeft";
pot_input_CodeValue.ArrowRight = "ArrowRight";
pot_input_CodeValue.End = "End";
pot_input_CodeValue.ArrowDown = "ArrowDown";
pot_input_CodeValue.PageDown = "PageDown";
pot_input_CodeValue.Insert = "Insert";
pot_input_CodeValue.Delete = "Delete";
pot_input_CodeValue.ContextMenu = "ContextMenu";
pot_input_CodeValue.DIGITS = ["Digit0","Digit1","Digit2","Digit3","Digit4","Digit5","Digit6","Digit7","Digit8","Digit9"];
pot_input_CodeValue.FUNCTIONS = ["F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12"];
pot_input_CodeValue.ALL = ["Escape","Digit0","Digit1","Digit2","Digit3","Digit4","Digit5","Digit6","Digit7","Digit8","Digit9","Minus","Equal","Backspace","Tab","KeyQ","KeyW","KeyE","KeyR","KeyT","KeyY","KeyU","KeyI","KeyO","KeyP","BracketLeft","BracketRight","Enter","ControlLeft","KeyA","KeyS","KeyD","KeyF","KeyG","KeyH","KeyJ","KeyK","KeyL","Semicolon","Quote","Backquote","ShiftLeft","Backslash","KeyZ","KeyX","KeyC","KeyV","KeyB","KeyN","KeyM","Comma","Period","Slash","ShiftRight","NumpadMultiply","AltLeft","Space","CapsLock","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","Numpad7","Numpad8","Numpad9","NumpadSubtract","Numpad4","Numpad5","Numpad6","NumpadAdd","Numpad1","Numpad2","Numpad3","Numpad0","NumpadDecimal","IntlBackslash","F11","F12","IntlYen","NumpadEnter","ControlRight","NumpadDivide","PrintScreen","AltRight","NumLock","Home","ArrowUp","PageUp","ArrowLeft","ArrowRight","End","ArrowDown","PageDown","Insert","Delete","ContextMenu"];
pot_input_KeyValue.Alt = "Alt";
pot_input_KeyValue.CapsLock = "CapsLock";
pot_input_KeyValue.Control = "Control";
pot_input_KeyValue.Meta = "Meta";
pot_input_KeyValue.NumLock = "NumLock";
pot_input_KeyValue.Shift = "Shift";
pot_input_KeyValue.Enter = "Enter";
pot_input_KeyValue.Tab = "Tab";
pot_input_KeyValue.Space = " ";
pot_input_KeyValue.ArrowDown = "ArrowDown";
pot_input_KeyValue.ArrowLeft = "ArrowLeft";
pot_input_KeyValue.ArrowRight = "ArrowRight";
pot_input_KeyValue.ArrowUp = "ArrowUp";
pot_input_KeyValue.End = "End";
pot_input_KeyValue.Home = "Home";
pot_input_KeyValue.PageDown = "PageDown";
pot_input_KeyValue.PageUp = "PageUp";
pot_input_KeyValue.Backspace = "Backspace";
pot_input_KeyValue.Delete = "Delete";
pot_input_KeyValue.Insert = "Insert";
pot_input_KeyValue.ContextMenu = "ContextMenu";
pot_input_KeyValue.Escape = "Escape";
pot_input_KeyValue.F1 = "F1";
pot_input_KeyValue.F2 = "F2";
pot_input_KeyValue.F3 = "F3";
pot_input_KeyValue.F4 = "F4";
pot_input_KeyValue.F5 = "F5";
pot_input_KeyValue.F6 = "F6";
pot_input_KeyValue.F7 = "F7";
pot_input_KeyValue.F8 = "F8";
pot_input_KeyValue.F9 = "F9";
pot_input_KeyValue.F10 = "F10";
pot_input_KeyValue.F11 = "F11";
pot_input_KeyValue.F12 = "F12";
pot_input_KeyValue.DIGITS = ["0","1","2","3","4","5","6","7","8","9"];
pot_input_KeyValue.FUNCTIONS = ["F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12"];
Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
