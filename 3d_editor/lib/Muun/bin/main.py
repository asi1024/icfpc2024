# Generated by Haxe 4.1.3
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math


class Main:
    __slots__ = ()

    @staticmethod
    def main():
        x = 1
        y = 2
        z = 3
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        a_x = x
        a_y = y
        a_z = z
        x = 4
        y = 5
        z = 6
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        b_x = x
        b_y = y
        b_z = z
        x = (a_x * 2)
        y = (a_y * 2)
        z = (a_z * 2)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        a_x = x
        a_y = y
        a_z = z
        x = (b_x * 3)
        y = (b_y * 3)
        z = (b_z * 3)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        b_x1 = x
        b_y1 = y
        b_z1 = z
        x = (a_x + b_x1)
        y = (a_y + b_y1)
        z = (a_z + b_z1)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        b_x1 = x
        b_y1 = y
        b_z1 = z
        x = (5 / b_x1)
        y = (5 / b_y1)
        z = (5 / b_z1)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        a_x = x
        a_y = y
        a_z = z
        x = (a_x * b_x)
        y = (a_y * b_y)
        z = (a_z * b_z)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        a_x = x
        a_y = y
        a_z = z
        v = (((a_x * a_x) + ((a_y * a_y))) + ((a_z * a_z)))
        print(str(((str(a_x) + " ") + str(((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v)))))))


class haxe_iterators_ArrayIterator:
    __slots__ = ("array", "current")

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()



class muun_la__Vec3_Vec3_Impl_:
    __slots__ = ()

    @staticmethod
    def _new(x = None,y = None,z = None):
        if (x is None):
            x = 0.0
        if (y is None):
            y = 0.0
        if (z is None):
            z = 0.0
        this1 = muun_la__Vec3_Vec3Data(x,y,z)
        return this1

    @staticmethod
    def normalize(this1):
        a = this1
        a1 = a
        v = (((a1.x * a.x) + ((a1.y * a.y))) + ((a1.z * a.z)))
        l = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        if (l > 0):
            l = (1 / l)
        x = (a.x * l)
        y = (a.y * l)
        z = (a.z * l)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        this1 = muun_la__Vec3_Vec3Data(x,y,z)
        a = this1
        return a

    @staticmethod
    def normalized(this1):
        a = this1
        a1 = a
        v = (((a1.x * a.x) + ((a1.y * a.y))) + ((a1.z * a.z)))
        l = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        if (l > 0):
            l = (1 / l)
        x = (a.x * l)
        y = (a.y * l)
        z = (a.z * l)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        this1 = muun_la__Vec3_Vec3Data(x,y,z)
        return this1

    @staticmethod
    def length(this1):
        a = this1
        v = (((a.x * this1.x) + ((a.y * this1.y))) + ((a.z * this1.z)))
        if (v < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v)

    @staticmethod
    def dot(this1,b):
        a = this1
        return (((a.x * b.x) + ((a.y * b.y))) + ((a.z * b.z)))

    @staticmethod
    def add(a,b):
        x = (a.x + b.x)
        y = (a.y + b.y)
        z = (a.z + b.z)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        this1 = muun_la__Vec3_Vec3Data(x,y,z)
        return this1

    @staticmethod
    def sub(a,b):
        x = (a.x - b.x)
        y = (a.y - b.y)
        z = (a.z - b.z)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        this1 = muun_la__Vec3_Vec3Data(x,y,z)
        return this1

    @staticmethod
    def mul(a,b):
        x = (a.x * b.x)
        y = (a.y * b.y)
        z = (a.z * b.z)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        this1 = muun_la__Vec3_Vec3Data(x,y,z)
        return this1

    @staticmethod
    def div(a,b):
        x = (a.x / b.x)
        y = (a.y / b.y)
        z = (a.z / b.z)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        this1 = muun_la__Vec3_Vec3Data(x,y,z)
        return this1

    @staticmethod
    def scale(a,b):
        x = (a.x * b)
        y = (a.y * b)
        z = (a.z * b)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        this1 = muun_la__Vec3_Vec3Data(x,y,z)
        return this1

    @staticmethod
    def divf(a,b):
        x = (a.x / b)
        y = (a.y / b)
        z = (a.z / b)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        this1 = muun_la__Vec3_Vec3Data(x,y,z)
        return this1

    @staticmethod
    def fdiv(a,b):
        x = (a / b.x)
        y = (a / b.y)
        z = (a / b.z)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        this1 = muun_la__Vec3_Vec3Data(x,y,z)
        return this1

    @staticmethod
    def addEq(this1,b):
        x = (this1.x + b.x)
        y = (this1.y + b.y)
        z = (this1.z + b.z)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        v_x = x
        v_y = y
        v_z = z
        this1.x = v_x
        this1.y = v_y
        this1.z = v_z
        return this1

    @staticmethod
    def subEq(this1,b):
        x = (this1.x - b.x)
        y = (this1.y - b.y)
        z = (this1.z - b.z)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        v_x = x
        v_y = y
        v_z = z
        this1.x = v_x
        this1.y = v_y
        this1.z = v_z
        return this1

    @staticmethod
    def scaleEq(this1,b):
        a = this1
        x = (a.x * b)
        y = (a.y * b)
        z = (a.z * b)
        if (z is None):
            z = 0.0
        if (y is None):
            y = 0.0
        if (x is None):
            x = 0.0
        v_x = x
        v_y = y
        v_z = z
        this1.x = v_x
        this1.y = v_y
        this1.z = v_z
        return this1

    @staticmethod
    def copyFrom(this1,v):
        this1.x = v.x
        this1.y = v.y
        this1.z = v.z
        return this1


class muun_la__Vec3_Vec3Data:
    __slots__ = ("x", "y", "z")

    def __init__(self,x,y,z):
        self.x = x
        self.y = y
        self.z = z



class python_internal_ArrayImpl:
    __slots__ = ()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None


class HxOverrides:
    __slots__ = ()

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s


class python_internal_MethodClosure:
    __slots__ = ("obj", "func")

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)


Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi


Main.main()
